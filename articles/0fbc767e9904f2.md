---
title: "Astroで構築したWEBサイトの差分納品を自動化する"
emoji: "🐷"
type: "tech"
topics: []
published: false
---

Webサイトの運用において、コンテンツやデザインの更新は頻繁に行われます。特に大規模なサイトや更新頻度の高いサイトでは、更新のたびに全ファイルを納品するのは非効率的であり、時間とコストがかかります。

本記事では、静的サイトジェネレーターである Astro で構築されたサイトの更新プロセスにおいて、変更があったファイルのみを差分として検出し、自動で納品する仕組みを AWS Lambda と GitHub Actions を用いて実現した事例をご紹介します。

### 背景と目的

私たちが運用する Astro ベースの Web サイトでは、コンテンツ更新や機能改善が日々行われています。従来は、更新があるたびにサイト全体をビルドし、生成された全ファイルをクライアントや関係部署に納品していました。しかし、この方法では以下のような課題がありました。

*   **非効率性**: 変更されていないファイルも含めて毎回大量のファイルを転送・確認する必要がある。
*   **確認漏れのリスク**: 変更箇所が埋もれてしまい、重要な変更が見落とされる可能性がある。
*   **時間とコスト**: ビルド成果物のアップロードやダウンロード、差分確認に多くの時間と手間がかかる。

これらの課題を解決するため、**前回の納品物と比較して変更があったファイルのみを抽出し、差分ファイルとして自動で納品する仕組み**を構築することを目的としました。これにより、納品プロセスの効率化と確実性の向上を目指します。

承知いたしました。Slack スラッシュコマンドと SQS を利用した非同期処理に関する補足情報を反映させて、「環境」と「システム構成図（概念）」のセクションを修正します。

---

### 環境

この仕組みを実現するために利用している主な技術スタックとサービスは以下の通りです。

*   **Webフレームワーク**: [Astro](https://astro.build/)
*   **CI/CD**: [GitHub Actions](https://github.co.jp/features/actions)
*   **差分検出・パッケージング**:
    *   **同期応答用 Lambda**: [AWS Lambda](https://aws.amazon.com/jp/lambda/) (Node.js ランタイム) - Slack スラッシュコマンドへの即時応答と SQS へのキューイング担当 (`site-deliverable-generator`)
    *   **非同期処理用 Lambda**: [AWS Lambda](https://aws.amazon.com/jp/lambda/) (Node.js ランタイム) - 実際の差分検出・パッケージング処理担当 (`site-deliverable-generator-async`)
*   **メッセージキュー**: [AWS SQS](https://aws.amazon.com/jp/sqs/) - 同期 Lambda と非同期 Lambda の連携
*   **ビルド成果物・差分ファイル保存**: [AWS S3](https://aws.amazon.com/jp/s3/)
*   **コミュニケーションツール**: [Slack](https://slack.com/) (スラッシュコマンドによる差分生成トリガー、完了通知)

### システム構成図（概念）

この差分納品システムの全体的なフローは以下のようになります。

1.  **コード変更 & プッシュ (ビルド成果物更新)**:
    *   開発者が Git リポジトリにコードをプッシュします。
    *   GitHub Actions (`site_push.yml` や `microcms_webhook.yml`) が実行され、Astro サイトがビルドされ、最新の成果物が S3 にアップロードされます。
2.  **Slack スラッシュコマンド実行 (差分生成指示)**:
    *   ユーザーが Slack で特定の スラッシュコマンド (例: `/deliverable-diff`) を実行し、差分納品ファイルの生成を指示します。
3.  **同期応答 Lambda (`site-deliverable-generator`)**:
    *   API Gateway 経由で Slack スラッシュコマンドのリクエストを受け取ります。
    *   リクエスト内容（対象期間など）を含むメッセージを SQS キューに送信します。
    *   **3 秒以内に** Slack に「差分ファイルの生成を開始しました。完了までしばらくお待ちください。」のような即時応答を返します。(タイムアウト回避)
4.  **SQS キュー**:
    *   同期応答 Lambda から送信された差分生成ジョブメッセージを保持します。
5.  **非同期処理 Lambda (`site-deliverable-generator-async`)**:
    *   SQS キューをポーリング（またはイベントトリガーで起動）し、差分生成ジョブメッセージを取得します。
    *   メッセージに基づき、S3 から最新のビルド成果物と、比較対象となる前回のビルド成果物をダウンロードします。
    *   ファイルリストやハッシュ値を比較し、差分（追加・変更・削除されたファイル）を検出します。
    *   差分ファイルのみを含む ZIP パッケージを作成し、指定された S3 バケットにアップロードします。
6.  **差分ファイル納品 & Slack 通知**:
    *   非同期処理 Lambda は、差分 ZIP ファイルの S3 アップロードが完了したら、そのダウンロード用 URL を含んだメッセージを作成します。
    *   Slack の Incoming Webhook などを使用して、指定されたチャンネルに「差分ファイルの準備ができました: [ダウンロード URL]」のような完了通知を送信します。
7.  **(Lambda デプロイ)**:
    *   `lambda` ディレクトリ内のコードに変更があった場合、`lambda-deploy.yml` ワークフローが起動し、上記 2 つの Lambda 関数 (`site-deliverable-generator`, `site-deliverable-generator-async`) を AWS Lambda にデプロイします。

*(注: API Gateway や SQS の詳細設定、Lambda 関数の具体的なトリガー設定などは提供されたファイルからは直接読み取れないため、一般的な構成に基づいた説明となります。)*

### コード例

この差分納品システムの中核となるのは、Slack からの指示を受け付ける同期 Lambda と、実際の差分処理を行う非同期 Lambda です。ここでは、それぞれの Lambda 関数の骨組みとなる Node.js のコード例と、関連する設定について解説します。

*(注: 以下のコードは主要な処理の流れを示すサンプルであり、完全なエラーハンドリングや具体的な差分比較ロジックは含まれていません。ご自身の要件に合わせて適宜修正・追記してください。)*

**1. 同期応答 Lambda (`lambda/diff/index.js`)**

この Lambda 関数は、API Gateway 経由で Slack スラッシュコマンドのリクエストを受け取り、SQS にジョブをキューイングし、Slack に即時応答を返します。

```javascript
// lambda/diff/index.js
const { SQSClient, SendMessageCommand } = require("@aws-sdk/client-sqs");
const querystring = require('querystring');

const sqsClient = new SQSClient({ region: process.env.AWS_REGION }); // リージョンは環境変数から取得
const sqsQueueUrl = process.env.SQS_QUEUE_URL; // SQS キューの URL を環境変数から取得

exports.handler = async (event) => {
    console.log("Received event:", JSON.stringify(event, null, 2));

    // Slack スラッシュコマンドのリクエストボディをパース
    // API Gateway の統合設定によっては event.body が Base64 エンコードされている場合がある
    let body;
    if (event.isBase64Encoded) {
        body = Buffer.from(event.body, 'base64').toString('utf8');
    } else {
        body = event.body;
    }
    const params = querystring.parse(body);
    console.log("Parsed params:", params);

    // TODO: 必要に応じてリクエストの検証 (例: Slack の Signing Secret 検証) を行う

    // SQS に送信するメッセージを作成
    // 例: コマンドのテキスト部分を使って比較対象のバージョンなどを指定
    const messageBody = {
        command: params.command,
        text: params.text, // 例: "compare_with=previous_stable" のような情報
        response_url: params.response_url, // 非同期で応答を返すための URL
        triggered_user: params.user_name,
        // その他必要な情報
    };

    const sqsParams = {
        QueueUrl: sqsQueueUrl,
        MessageBody: JSON.stringify(messageBody),
        // DelaySeconds: 0, // 必要に応じて遅延設定
    };

    try {
        // SQS にメッセージを送信
        await sqsClient.send(new SendMessageCommand(sqsParams));
        console.log("Successfully sent message to SQS:", sqsParams.MessageBody);

        // Slack に即時応答を返す (3秒以内にレスポンス)
        return {
            statusCode: 200,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                response_type: 'ephemeral', // 'in_channel' または 'ephemeral'
                text: '差分ファイルの生成リクエストを受け付けました。完了までしばらくお待ちください。 :hourglass_flowing_sand:',
            }),
        };
    } catch (error) {
        console.error("Error sending message to SQS or responding to Slack:", error);
        return {
            statusCode: 500,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                response_type: 'ephemeral',
                text: 'エラーが発生しました。リクエストを処理できませんでした。',
            }),
        };
    }
};
```

**`lambda/diff/package.json` (例)**

```json
{
  "name": "site-deliverable-generator",
  "version": "1.0.0",
  "description": "Lambda function to receive Slack command and queue diff job.",
  "main": "index.js",
  "dependencies": {
    "@aws-sdk/client-sqs": "^3.0.0" // AWS SDK v3 for SQS
    // querystring は Node.js 標準モジュール
  },
  "devDependencies": {},
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC"
}
```

**2. 非同期処理 Lambda (`lambda/async/index.js`)**

この Lambda 関数は、SQS からのイベントをトリガーに実行され、S3 からビルド成果物をダウンロードし、差分比較、ZIP パッケージング、S3 へのアップロード、Slack への完了通知を行います。

```javascript
// lambda/async/index.js
const { S3Client, GetObjectCommand, PutObjectCommand, ListObjectsV2Command } = require("@aws-sdk/client-s3");
const { SQSClient } = require("@aws-sdk/client-sqs"); // SQSメッセージの削除に必要なら
const fs = require('fs').promises;
const path = require('path');
const os = require('os');
const { Readable } = require('stream');
const { PassThrough } = require('stream');
const archiver = require('archiver');
const https = require('https'); // Slack通知用

const s3Client = new S3Client({ region: process.env.AWS_REGION });
const sqsClient = new SQSClient({ region: process.env.AWS_REGION }); // 必要なら
const buildBucket = process.env.BUILD_BUCKET_NAME;     // ビルド成果物バケット
const deliverableBucket = process.env.DELIVERABLE_BUCKET_NAME; // 差分納品物バケット
const slackWebhookUrl = process.env.SLACK_WEBHOOK_URL; // Slack Incoming Webhook URL

// --- Helper Functions ---

// S3からファイルをダウンロードして一時ディレクトリに保存する関数
async function downloadFromS3(bucket, prefix, targetDir) {
    try {
        console.log(`Downloading files from s3://${bucket}/${prefix} to ${targetDir}`);
        const listParams = { Bucket: bucket, Prefix: prefix };
        let isTruncated = true;
        let continuationToken;

        while (isTruncated) {
            const listCmd = new ListObjectsV2Command({ ...listParams, ContinuationToken: continuationToken });
            const data = await s3Client.send(listCmd);

            if (!data.Contents || data.Contents.length === 0) {
                console.log(`No objects found in s3://${bucket}/${prefix}`);
                return; // オブジェクトがない場合は終了
            }

            await Promise.all(data.Contents.map(async (item) => {
                if (!item.Key || item.Key.endsWith('/')) return; // ディレクトリはスキップ

                const targetPath = path.join(targetDir, path.relative(prefix, item.Key));
                await fs.mkdir(path.dirname(targetPath), { recursive: true });

                const getParams = { Bucket: bucket, Key: item.Key };
                const getCmd = new GetObjectCommand(getParams);
                const response = await s3Client.send(getCmd);

                if (response.Body instanceof Readable) {
                    const fileStream = require('fs').createWriteStream(targetPath); // fsの同期版を使用
                    await new Promise((resolve, reject) => {
                         response.Body.pipe(fileStream)
                            .on('error', reject)
                            .on('close', resolve);
                    });
                   console.log(`Downloaded ${item.Key} to ${targetPath}`);
                } else {
                   console.warn(`Skipping non-readable object: ${item.Key}`);
                }
            }));

            isTruncated = data.IsTruncated;
            continuationToken = data.NextContinuationToken;
        }
        console.log(`Finished downloading from s3://${bucket}/${prefix}`);
    } catch (error) {
        console.error(`Error downloading from S3 (Bucket: ${bucket}, Prefix: ${prefix}):`, error);
        throw error; // エラーを再スローして呼び出し元で処理
    }
}


// ファイルリストとハッシュを取得する関数 (実装例)
async function getFileManifest(dir) {
    const manifest = {};
    const files = await fs.readdir(dir, { withFileTypes: true, recursive: true }); // Node.js 18.17+
    for (const file of files) {
        if (file.isFile()) {
            const filePath = path.join(file.path, file.name); // Node.js 20+ では file.fullpath
            const relativePath = path.relative(dir, filePath);
            const content = await fs.readFile(filePath);
            const hash = require('crypto').createHash('sha256').update(content).digest('hex');
            manifest[relativePath] = hash;
        }
    }
    return manifest;
}

// 差分を比較する関数 (実装例)
function compareManifests(oldManifest, newManifest) {
    const diff = { added: [], modified: [], deleted: [] };
    const allKeys = new Set([...Object.keys(oldManifest), ...Object.keys(newManifest)]);

    for (const key of allKeys) {
        if (!oldManifest[key] && newManifest[key]) {
            diff.added.push(key);
        } else if (oldManifest[key] && !newManifest[key]) {
            diff.deleted.push(key); // 削除されたファイルも情報として返す
        } else if (oldManifest[key] !== newManifest[key]) {
            diff.modified.push(key);
        }
    }
    return diff;
}

// 指定されたファイルリストからZIPを作成し、S3にアップロードする関数
async function createAndUploadZip(filesToInclude, sourceDir, zipFileName, targetBucket, targetPrefix) {
    const zipFilePath = path.join(os.tmpdir(), zipFileName);
    const output = require('fs').createWriteStream(zipFilePath); // 同期版 fs
    const archive = archiver('zip', { zlib: { level: 9 } });

    return new Promise(async (resolve, reject) => {
        output.on('close', async () => {
            console.log(archive.pointer() + ' total bytes');
            console.log('Archiver has been finalized and the output file descriptor has closed.');
            try {
                const fileContent = await fs.readFile(zipFilePath);
                const uploadParams = {
                    Bucket: targetBucket,
                    Key: path.join(targetPrefix, zipFileName),
                    Body: fileContent,
                    ContentType: 'application/zip',
                };
                const putCmd = new PutObjectCommand(uploadParams);
                await s3Client.send(putCmd);
                console.log(`Successfully uploaded ${zipFileName} to s3://${targetBucket}/${targetPrefix}`);
                await fs.unlink(zipFilePath); // 一時ファイルを削除
                resolve(path.join(targetPrefix, zipFileName)); // S3のキーを返す
            } catch (err) {
                reject(`Error uploading zip to S3 or deleting temp file: ${err}`);
            }
        });

        archive.on('warning', (err) => {
            if (err.code === 'ENOENT') {
                console.warn('Archiver warning: ', err);
            } else {
                reject(err);
            }
        });

        archive.on('error', (err) => {
            reject(`Archiver error: ${err}`);
        });

        archive.pipe(output);

        // 差分ファイルを追加 (追加・変更されたもの)
        for (const fileRelativePath of filesToInclude) {
            const sourceFilePath = path.join(sourceDir, fileRelativePath);
            try {
                // ファイルが存在するか確認してから追加
                await fs.access(sourceFilePath);
                archive.file(sourceFilePath, { name: fileRelativePath });
                console.log(`Adding to zip: ${fileRelativePath}`);
            } catch (accessError) {
                 console.warn(`Skipping file (not found or inaccessible): ${sourceFilePath}`);
            }
        }

        // TODO: 必要であれば、削除されたファイルリストを含むテキストファイルなどをZIPに追加

        await archive.finalize();
    });
}

// Slackに通知を送る関数
async function sendSlackNotification(webhookUrl, message) {
    return new Promise((resolve, reject) => {
        const payload = JSON.stringify({ text: message });
        const options = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(payload),
            },
        };

        const req = https.request(webhookUrl, options, (res) => {
            let responseBody = '';
            res.on('data', (chunk) => { responseBody += chunk; });
            res.on('end', () => {
                if (res.statusCode >= 200 && res.statusCode < 300) {
                    console.log('Slack notification sent successfully.');
                    resolve();
                } else {
                    reject(`Slack notification failed with status ${res.statusCode}: ${responseBody}`);
                }
            });
        });

        req.on('error', (e) => {
            reject(`Error sending Slack notification: ${e.message}`);
        });

        req.write(payload);
        req.end();
    });
}


// --- Main Handler ---

exports.handler = async (event) => {
    console.log("Received SQS event:", JSON.stringify(event, null, 2));

    for (const record of event.Records) {
        const messageBody = JSON.parse(record.body);
        console.log("Processing message:", messageBody);

        // Slackの応答URL (response_url) を取得
        const responseUrl = messageBody.response_url;

        // 一時ディレクトリを作成
        const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'diff-'));
        const currentDir = path.join(tempDir, 'current');
        const previousDir = path.join(tempDir, 'previous');
        await fs.mkdir(currentDir);
        await fs.mkdir(previousDir);

        try {
            // TODO: messageBody.text などから比較対象のバージョンを取得するロジック
            // ここでは例として 'latest' と 'previous_stable' プレフィックスを使用
            const currentVersionPrefix = 'builds/latest'; // S3上の最新ビルドのプレフィックス (実際の構造に合わせる)
            const previousVersionPrefix = 'builds/previous_stable'; // S3上の比較対象ビルドのプレフィックス

            // S3から最新版と旧版をダウンロード
            await downloadFromS3(buildBucket, currentVersionPrefix, currentDir);
            await downloadFromS3(buildBucket, previousVersionPrefix, previousDir);

            // ファイルマニフェストを作成
            const currentManifest = await getFileManifest(currentDir);
            const previousManifest = await getFileManifest(previousDir);

            // 差分を比較
            const diffResult = compareManifests(previousManifest, currentManifest);
            console.log("Diff result:", diffResult);

            const filesToZip = [...diffResult.added, ...diffResult.modified];

            if (filesToZip.length === 0 && diffResult.deleted.length === 0) {
                 console.log("No changes detected.");
                 await sendSlackNotification(responseUrl, `差分はありませんでした。\n比較対象: ${previousVersionPrefix}\n最新: ${currentVersionPrefix}`);
            } else {
                // ZIPファイルを作成してS3にアップロード
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const zipFileName = `deliverable_diff_${timestamp}.zip`;
                const deliverablePrefix = 'deliverables'; // 納品物を置くプレフィックス

                const s3ZipKey = await createAndUploadZip(filesToZip, currentDir, zipFileName, deliverableBucket, deliverablePrefix);

                // S3の署名付きURLなどを生成してダウンロードURLを作成 (ここでは簡易的なURL)
                // TODO: 必要に応じて署名付きURL生成ロジックを追加
                const downloadUrl = `https://s3.${process.env.AWS_REGION}.amazonaws.com/${deliverableBucket}/${s3ZipKey}`;
                // const downloadUrl = `https://${deliverableBucket}.s3.${process.env.AWS_REGION}.amazonaws.com/${s3ZipKey}`; // Virtual-hosted style

                // Slackに完了通知
                let slackMessage = `差分ファイルの準備ができました！ :tada:\n`;
                slackMessage += `ダウンロード: ${downloadUrl}\n`;
                slackMessage += `比較対象: ${previousVersionPrefix}, 最新: ${currentVersionPrefix}\n`;
                if (diffResult.added.length > 0) slackMessage += `追加: ${diffResult.added.length}件\n`;
                if (diffResult.modified.length > 0) slackMessage += `変更: ${diffResult.modified.length}件\n`;
                if (diffResult.deleted.length > 0) slackMessage += `削除: ${diffResult.deleted.length}件\n`; // 削除ファイル情報も通知

                await sendSlackNotification(responseUrl, slackMessage);
            }

             // TODO: 処理が正常に完了したらSQSメッセージを削除する (Lambdaのトリガー設定で自動削除も可能)
             // const deleteParams = { QueueUrl: sqsQueueUrl, ReceiptHandle: record.receiptHandle };
             // await sqsClient.send(new DeleteMessageCommand(deleteParams));

        } catch (error) {
            console.error("Error processing diff job:", error);
            // エラーが発生した場合もSlackに応答を返す
            try {
                 await sendSlackNotification(responseUrl, `差分ファイルの生成中にエラーが発生しました: ${error.message}`);
            } catch (slackError) {
                 console.error("Failed to send error notification to Slack:", slackError);
            }
            // TODO: エラー内容に応じてメッセージをリトライさせるか、デッドレターキューに送るかなどを検討
            throw error; // エラーを再スローしてLambda実行を失敗させる
        } finally {
            // 一時ディレクトリをクリーンアップ
            try {
                await fs.rm(tempDir, { recursive: true, force: true });
                console.log("Cleaned up temporary directory:", tempDir);
            } catch (cleanupError) {
                console.error("Error cleaning up temporary directory:", cleanupError);
            }
        }
    }
};
```

**`lambda/async/package.json` (例)**

```json
{
  "name": "site-deliverable-generator-async",
  "version": "1.0.0",
  "description": "Lambda function to perform diff, zip, upload, and notify Slack.",
  "main": "index.js",
  "dependencies": {
    "@aws-sdk/client-s3": "^3.0.0",
    "@aws-sdk/client-sqs": "^3.0.0", // 必要なら
    "archiver": "^6.0.0" // ZIP作成用
    // crypto, fs, path, os, https は Node.js 標準モジュール
  },
  "devDependencies": {},
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC"
}
```

**3. GitHub Actions (`.github/workflows/lambda-deploy.yml`)**

これは記事の前半で示したものと同様です。`lambda/diff` と `lambda/async` の各ディレクトリで `npm install` を実行し、`zip` コマンドでパッケージング、`aws lambda update-function-code` でデプロイします。

```yaml
# .github/workflows/lambda-deploy.yml (抜粋)
# ... (前述の通り) ...

      - name: Install dependencies for diff Lambda
        working-directory: lambda/diff
        run: npm install # package.json に基づき aws-sdk などをインストール

      - name: Build and package diff Lambda function
        working-directory: lambda/diff
        run: |
          # node_modules も含めて zip 化
          zip -r function.zip . -x ".git/*" "node_modules/aws-sdk/*" # aws-sdkはLambda環境に用意されているため除外可

      - name: Deploy diff Lambda function
        run: |
          aws lambda update-function-code --function-name site-deliverable-generator --zip-file fileb://lambda/diff/function.zip
        # ... env ...

      - name: Install dependencies for async Lambda
        working-directory: lambda/async
        run: npm install # archiver などをインストール

      - name: Build and package async Lambda function
        working-directory: lambda/async
        run: |
          zip -r function.zip . -x ".git/*" "node_modules/aws-sdk/*"

      - name: Deploy async Lambda function
        run: |
          aws lambda update-function-code --function-name site-deliverable-generator-async --zip-file fileb://lambda/async/function.zip
        # ... env ...
```

**4. 前提条件と設定**

*   **IAM ロール**: 各 Lambda 関数には適切な IAM ロールが必要です。
    *   `site-deliverable-generator`: SQS への書き込み権限 (`sqs:SendMessage`)、CloudWatch Logs への書き込み権限。
    *   `site-deliverable-generator-async`: SQS からの読み込み/削除権限 (`sqs:ReceiveMessage`, `sqs:DeleteMessage`)、S3 バケットへの読み取り (`s3:GetObject`, `s3:ListBucket`) および書き込み権限 (`s3:PutObject`)、CloudWatch Logs への書き込み権限。
*   **環境変数**: Lambda 関数には以下の環境変数を設定する必要があります。
    *   `AWS_REGION`: 例: `ap-northeast-1`
    *   `SQS_QUEUE_URL`: 同期 Lambda がメッセージを送る SQS キューの URL。
    *   `BUILD_BUCKET_NAME`: Astro のビルド成果物が置かれる S3 バケット名。
    *   `DELIVERABLE_BUCKET_NAME`: 差分 ZIP ファイルを保存する S3 バケット名。
    *   `SLACK_WEBHOOK_URL`: 非同期 Lambda が通知を送る Slack Incoming Webhook の URL (または `response_url` を使う場合は不要)。
*   **API Gateway**: Slack スラッシュコマンドからの POST リクエストを受け付け、同期 Lambda (`site-deliverable-generator`) をトリガーするように設定します。リクエストボディを Lambda に渡す統合設定が必要です。
*   **SQS**: Lambda 関数間でメッセージを受け渡すための標準キューを作成します。非同期 Lambda (`site-deliverable-generator-async`) のトリガーとしてこの SQS キューを設定します。必要に応じてデッドレターキューも設定します。
*   **Slack App**: スラッシュコマンドを作成し、リクエスト URL として API Gateway のエンドポイントを指定します。Signing Secret を使用したリクエスト検証を Lambda 側で実装することが推奨されます。

これらのコード例と設定の概要が、システムの実装を進める上での助けになれば幸いです。

### 実行例

この差分納品システムは、以下のステップで実行されます。

1.  **ビルド成果物の更新 (前提)**: 開発者が Astro プロジェクトのコードを変更し GitHub にプッシュするか、microCMS のコンテンツが更新されると、GitHub Actions のビルドワークフロー (`site_push.yml` または `microcms_webhook.yml`) が実行されます。これにより、最新の Web サイト全体がビルドされ、その成果物が S3 バケット (`s3://your-build-bucket/builds/latest/` のようなプレフィックス) にアップロードされます。
2.  **差分生成の指示 (Slack)**: 運用担当者や開発者が、納品用の差分ファイルが必要になったタイミングで、Slack クライアントからスラッシュコマンドを実行します。
    *   例: `/deliverable-diff compare_with=previous_stable`
    *   このコマンドは、API Gateway を介して同期応答 Lambda (`site-deliverable-generator`) に送信されます。
3.  **リクエスト受付とキューイング**: 同期応答 Lambda は Slack からのリクエストを受け取ります。
    *   どのバージョンと比較するか (例: `previous_stable`) といった情報をパースします。
    *   このジョブ情報を SQS キューに送信します。
    *   Slack に対して **3 秒以内に** 「差分ファイルの生成リクエストを受け付けました。完了までしばらくお待ちください。 :hourglass_flowing_sand:」といった応答メッセージを（通常は実行ユーザーにのみ見える形で）返信します。これにより、Slack 側のタイムアウトを防ぎます。
4.  **差分処理の実行 (非同期)**: SQS キューを監視している非同期処理 Lambda (`site-deliverable-generator-async`) が、キューに入れられたジョブメッセージを検知して起動します。
5.  **ファイル比較とパッケージング**:
    *   非同期 Lambda は、メッセージ内の指示に基づき、S3 から最新のビルド成果物 (`s3://your-build-bucket/builds/latest/`) と比較対象のビルド成果物 (`s3://your-build-bucket/builds/previous_stable/` など) を一時領域にダウンロードします。
    *   両方のディレクトリ構造とファイル内容（ハッシュ値）を比較し、追加・変更・削除されたファイルを特定します。
    *   追加・変更されたファイルだけを収集し、`deliverable_diff_YYYYMMDDTHHMMSSZ.zip` のようなタイムスタンプ付きの ZIP ファイルを作成します。
6.  **差分ファイルのアップロードと完了通知**:
    *   作成された差分 ZIP ファイルを、納品用の S3 バケット (`s3://your-deliverable-bucket/deliverables/`) にアップロードします。
    *   アップロード後、Slack の `response_url` (ステップ 2 のリクエストに含まれていた) または設定された Incoming Webhook を使用して、元のスラッシュコマンドが実行されたチャンネルまたはユーザーに完了通知を送信します。
    *   通知メッセージ例:
        ```
        差分ファイルの準備ができました！ :tada:
        ダウンロード: https://your-deliverable-bucket.s3.ap-northeast-1.amazonaws.com/deliverables/deliverable_diff_2023-10-27T10-30-00Z.zip
        比較対象: builds/previous_stable, 最新: builds/latest
        追加: 5件
        変更: 12件
        削除: 2件
        ```
7.  **確認**: 関係者は Slack 通知内のリンクから差分 ZIP ファイルをダウンロードし、変更内容を確認します。

このフローにより、大規模なサイトであっても Slack コマンド実行から短時間で受付応答を得られ、実際の時間のかかる差分処理はバックグラウンドで実行され、完了後に結果が通知されるため、ユーザーは処理完了を待機する必要がありません。

### まとめ

AWS Lambda と GitHub Actions を活用することで、Astro サイトの更新における差分納品プロセスを自動化し、大幅な効率化を実現しました。この仕組みにより、開発者はコードの変更に集中でき、運用担当者やクライアントは変更内容の確認を迅速かつ容易に行えるようになります。

今後の展望としては、差分検出ロジックのさらなる最適化や、納品先に応じた柔軟な設定変更機能の追加などが考えられます。Web サイト運用の効率化を目指す上で、このような自動化の取り組みは非常に有効な手段の一つと言えるでしょう。
